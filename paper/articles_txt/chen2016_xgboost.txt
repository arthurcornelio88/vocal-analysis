XGBoost: A Scalable Tree Boosting System
Tianqi Chen

Carlos Guestrin

University of Washington

University of Washington

arXiv:1603.02754v3 [cs.LG] 10 Jun 2016

tqchen@cs.washington.edu

ABSTRACT
Tree boosting is a highly effective and widely used machine
learning method. In this paper, we describe a scalable endto-end tree boosting system called XGBoost, which is used
widely by data scientists to achieve state-of-the-art results
on many machine learning challenges. We propose a novel
sparsity-aware algorithm for sparse data and weighted quantile sketch for approximate tree learning. More importantly,
we provide insights on cache access patterns, data compression and sharding to build a scalable tree boosting system.
By combining these insights, XGBoost scales beyond billions
of examples using far fewer resources than existing systems.

Keywords
Large-scale Machine Learning

1.

INTRODUCTION

Machine learning and data-driven approaches are becoming very important in many areas. Smart spam classifiers
protect our email by learning from massive amounts of spam
data and user feedback; advertising systems learn to match
the right ads with the right context; fraud detection systems
protect banks from malicious attackers; anomaly event detection systems help experimental physicists to find events
that lead to new physics. There are two important factors
that drive these successful applications: usage of effective
(statistical) models that capture the complex data dependencies and scalable learning systems that learn the model
of interest from large datasets.
Among the machine learning methods used in practice,
gradient tree boosting [10]1 is one technique that shines
in many applications. Tree boosting has been shown to
give state-of-the-art results on many standard classification
benchmarks [16]. LambdaMART [5], a variant of tree boosting for ranking, achieves state-of-the-art result for ranking
1
Gradient tree boosting is also known as gradient boosting
machine (GBM) or gradient boosted regression tree (GBRT)

Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).

KDD â€™16, August 13-17, 2016, San Francisco, CA, USA
c 2016 Copyright held by the owner/author(s).
ACM ISBN .
DOI:

guestrin@cs.washington.edu

problems. Besides being used as a stand-alone predictor, it
is also incorporated into real-world production pipelines for
ad click through rate prediction [15]. Finally, it is the defacto choice of ensemble method and is used in challenges
such as the Netflix prize [3].
In this paper, we describe XGBoost, a scalable machine
learning system for tree boosting. The system is available as
an open source package2 . The impact of the system has been
widely recognized in a number of machine learning and data
mining challenges. Take the challenges hosted by the machine learning competition site Kaggle for example. Among
the 29 challenge winning solutions 3 published at Kaggleâ€™s
blog during 2015, 17 solutions used XGBoost. Among these
solutions, eight solely used XGBoost to train the model,
while most others combined XGBoost with neural nets in ensembles. For comparison, the second most popular method,
deep neural nets, was used in 11 solutions. The success
of the system was also witnessed in KDDCup 2015, where
XGBoost was used by every winning team in the top-10.
Moreover, the winning teams reported that ensemble methods outperform a well-configured XGBoost by only a small
amount [1].
These results demonstrate that our system gives state-ofthe-art results on a wide range of problems. Examples of
the problems in these winning solutions include: store sales
prediction; high energy physics event classification; web text
classification; customer behavior prediction; motion detection; ad click through rate prediction; malware classification;
product categorization; hazard risk prediction; massive online course dropout rate prediction. While domain dependent data analysis and feature engineering play an important
role in these solutions, the fact that XGBoost is the consensus choice of learner shows the impact and importance of
our system and tree boosting.
The most important factor behind the success of XGBoost
is its scalability in all scenarios. The system runs more than
ten times faster than existing popular solutions on a single
machine and scales to billions of examples in distributed or
memory-limited settings. The scalability of XGBoost is due
to several important systems and algorithmic optimizations.
These innovations include: a novel tree learning algorithm
is for handling sparse data; a theoretically justified weighted
quantile sketch procedure enables handling instance weights
in approximate tree learning. Parallel and distributed computing makes learning faster which enables quicker model exploration. More importantly, XGBoost exploits out-of-core
2
3

https://github.com/dmlc/xgboost
Solutions come from of top-3 teams of each competitions.

computation and enables data scientists to process hundred
millions of examples on a desktop. Finally, it is even more
exciting to combine these techniques to make an end-to-end
system that scales to even larger data with the least amount
of cluster resources. The major contributions of this paper
is listed as follows:
â€¢ We design and build a highly scalable end-to-end tree
boosting system.
â€¢ We propose a theoretically justified weighted quantile
sketch for efficient proposal calculation.
â€¢ We introduce a novel sparsity-aware algorithm for parallel tree learning.
â€¢ We propose an effective cache-aware block structure
for out-of-core tree learning.
While there are some existing works on parallel tree boosting [22, 23, 19], the directions such as out-of-core computation, cache-aware and sparsity-aware learning have not
been explored. More importantly, an end-to-end system
that combines all of these aspects gives a novel solution for
real-world use-cases. This enables data scientists as well as
researchers to build powerful variants of tree boosting algorithms [7, 8]. Besides these major contributions, we also
make additional improvements in proposing a regularized
learning objective, which we will include for completeness.
The remainder of the paper is organized as follows. We
will first review tree boosting and introduce a regularized
objective in Sec. 2. We then describe the split finding methods in Sec. 3 as well as the system design in Sec. 4, including
experimental results when relevant to provide quantitative
support for each optimization we describe. Related work
is discussed in Sec. 5. Detailed end-to-end evaluations are
included in Sec. 6. Finally we conclude the paper in Sec. 7.

2.

it into the leaves and calculate the final prediction by summing up the score in the corresponding leaves (given by w).
To learn the set of functions used in the model, we minimize
the following regularized objective.
X
X
L(Ï†) =
l(yÌ‚i , yi ) +
â„¦(fk )
i

yÌ‚i = Ï†(xi ) =

K
X

Gradient Tree Boosting

The tree ensemble model in Eq. (2) includes functions as
parameters and cannot be optimized using traditional optimization methods in Euclidean space. Instead, the model
(t)
is trained in an additive manner. Formally, let yÌ‚i be the
prediction of the i-th instance at the t-th iteration, we will
need to add ft to minimize the following objective.
L(t) =

fk (xi ), fk âˆˆ F ,
T

where F = {f (x) = wq(x) }(q : R â†’ T, w âˆˆ R ) is the
space of regression trees (also known as CART). Here q represents the structure of each tree that maps an example to
the corresponding leaf index. T is the number of leaves in the
tree. Each fk corresponds to an independent tree structure
q and leaf weights w. Unlike decision trees, each regression
tree contains a continuous score on each of the leaf, we use
wi to represent score on i-th leaf. For a given example, we
will use the decision rules in the trees (given by q) to classify

l(yi , yË†i (tâˆ’1) + ft (xi )) + â„¦(ft )

This means we greedily add the ft that most improves our
model according to Eq. (2). Second-order approximation
can be used to quickly optimize the objective in the general
setting [12].
L(t) â‰ƒ

m

n
X
i=1

(1)

k=1

(2)

Here l is a differentiable convex loss function that measures
the difference between the prediction yÌ‚i and the target yi .
The second term â„¦ penalizes the complexity of the model
(i.e., the regression tree functions). The additional regularization term helps to smooth the final learnt weights to avoid
over-fitting. Intuitively, the regularized objective will tend
to select a model employing simple and predictive functions.
A similar regularization technique has been used in Regularized greedy forest (RGF) [25] model. Our objective and
the corresponding learning algorithm is simpler than RGF
and easier to parallelize. When the regularization parameter is set to zero, the objective falls back to the traditional
gradient tree boosting.

Regularized Learning Objective

For a given data set with n examples and m features
D = {(xi , yi )} (|D| = n, xi âˆˆ Rm , yi âˆˆ R), a tree ensemble model (shown in Fig. 1) uses K additive functions to
predict the output.

k

1
where â„¦(f ) = Î³T + Î»kwk2
2

2.2

TREE BOOSTING IN A NUTSHELL

We review gradient tree boosting algorithms in this section. The derivation follows from the same idea in existing
literatures in gradient boosting. Specicially the second order
method is originated from Friedman et al. [12]. We make minor improvements in the reguralized objective, which were
found helpful in practice.

2.1

Figure 1: Tree Ensemble Model. The final prediction for a given example is the sum of predictions
from each tree.

n
X

[l(yi , yÌ‚ (tâˆ’1) ) + gi ft (xi ) +

i=1

1
hi ft2 (xi )] + â„¦(ft )
2

where gi = âˆ‚yÌ‚(tâˆ’1) l(yi , yÌ‚ (tâˆ’1) ) and hi = âˆ‚yÌ‚2(tâˆ’1) l(yi , yÌ‚ (tâˆ’1) )
are first and second order gradient statistics on the loss function. We can remove the constant terms to obtain the following simplified objective at step t.
LÌƒ(t) =

n
X
1
[gi ft (xi ) + hi ft2 (xi )] + â„¦(ft )
2
i=1

(3)

Algorithm 1: Exact Greedy Algorithm for Split Finding
Input: I, instance set of current node
Input: d, feature dimension
gain â†
P0
P
G â† iâˆˆI gi , H â† iâˆˆI hi
for k = 1 to m do
GL â† 0, HL â† 0
for j in sorted(I, by xjk ) do
GL â† GL + gj , HL â† HL + hj
GR â† G âˆ’ GL , HR â† H âˆ’ HL
G2
G2
G2
score â† max(score, HLL+Î» + HRR+Î» âˆ’ H+Î»
)
end
end
Output: Split with max score

Figure 2: Structure Score Calculation. We only
need to sum up the gradient and second order gradient statistics on each leaf, then apply the scoring
formula to get the quality score.
Define Ij = {i|q(xi ) = j} as the instance set of leaf j. We
can rewrite Eq (3) by expanding â„¦ as follows
LÌƒ(t) =

n
X

[gi ft (xi ) +

i=1

=

T
1 X 2
1
hi ft2 (xi )] + Î³T + Î»
wj
2
2 j=1

T
X
X
1 X
hi + Î»)wj2 ] + Î³T
[(
gi )wj + (
2
j=1 iâˆˆI
iâˆˆI
j

Algorithm 2: Approximate Algorithm for Split Finding
for k = 1 to m do
Propose Sk = {sk1 , sk2 , Â· Â· Â· skl } by percentiles on feature k.
Proposal can be done per tree (global), or per split(local).
end
for k = 1 to P
m do
Gkv â†= jâˆˆ{j|sk,v â‰¥xjk >sk,vâˆ’1 } gj
P
Hkv â†= jâˆˆ{j|sk,v â‰¥xjk >sk,vâˆ’1 } hj
end
Follow same step as in previous section to find max
score only among proposed splits.

(4)

j

For a fixed structure q(x), we can compute the optimal
weight wjâˆ— of leaf j by
P
iâˆˆIj gi
,
(5)
wjâˆ— = âˆ’ P
iâˆˆIj hi + Î»
and calculate the corresponding optimal value by
P
2
T
1 X ( iâˆˆIj gi )
(t)
P
+ Î³T.
LÌƒ (q) = âˆ’
2 j=1 iâˆˆIj hi + Î»

(6)

Eq (6) can be used as a scoring function to measure the
quality of a tree structure q. This score is like the impurity
score for evaluating decision trees, except that it is derived
for a wider range of objective functions. Fig. 2 illustrates
how this score can be calculated.
Normally it is impossible to enumerate all the possible
tree structures q. A greedy algorithm that starts from a
single leaf and iteratively adds branches to the tree is used
instead. Assume that IL and IR are the instance sets of left
and right nodes after the split. Lettting I = IL âˆª IR , then
the loss reduction after the split is given by
" P
#
P
P
2
( iâˆˆIR gi )2
( iâˆˆI gi )2
1 ( iâˆˆIL gi )
P
P
P
+
âˆ’
âˆ’Î³
Lsplit =
2
iâˆˆIL hi + Î»
iâˆˆIR hi + Î»
iâˆˆI hi + Î»
(7)
This formula is usually used in practice for evaluating the
split candidates.

2.3

Shrinkage and Column Subsampling

Besides the regularized objective mentioned in Sec. 2.1,
two additional techniques are used to further prevent overfitting. The first technique is shrinkage introduced by Friedman [11]. Shrinkage scales newly added weights by a factor
Î· after each step of tree boosting. Similar to a learning rate
in tochastic optimization, shrinkage reduces the influence of
each individual tree and leaves space for future trees to improve the model. The second technique is column (feature)
subsampling. This technique is used in RandomForest [4,

13], It is implemented in a commercial software TreeNet 4
for gradient boosting, but is not implemented in existing
opensource packages. According to user feedback, using column sub-sampling prevents over-fitting even more so than
the traditional row sub-sampling (which is also supported).
The usage of column sub-samples also speeds up computations of the parallel algorithm described later.

3.

SPLIT FINDING ALGORITHMS

3.1

Basic Exact Greedy Algorithm

One of the key problems in tree learning is to find the
best split as indicated by Eq (7). In order to do so, a split
finding algorithm enumerates over all the possible splits on
all the features. We call this the exact greedy algorithm.
Most existing single machine tree boosting implementations,
such as scikit-learn [20], Râ€™s gbm [21] as well as the single
machine version of XGBoost support the exact greedy algorithm. The exact greedy algorithm is shown in Alg. 1. It
is computationally demanding to enumerate all the possible
splits for continuous features. In order to do so efficiently,
the algorithm must first sort the data according to feature
values and visit the data in sorted order to accumulate the
gradient statistics for the structure score in Eq (7).

3.2

Approximate Algorithm

The exact greedy algorithm is very powerful since it enumerates over all possible splitting points greedily. However,
it is impossible to efficiently do so when the data does not fit
entirely into memory. Same problem also arises in the dis4

https://www.salford-systems.com/products/treenet

0.83
0.82

Test AUC

0.81
0.80
0.79
0.78

exact greedy
global eps=0.3
local eps=0.3
global eps=0.05

0.77
0.76
0.75
0

10

20

30
40
50
60
Number of Iterations

70

80

Figure 4: Tree structure with default directions. An
example will be classified into the default direction
when the feature needed for the split is missing.
90

Figure 3: Comparison of test AUC convergence on
Higgs 10M dataset. The eps parameter corresponds
to the accuracy of the approximate sketch. This
roughly translates to 1 / eps buckets in the proposal.
We find that local proposals require fewer buckets,
because it refine split candidates.

ture are used to make candidates distribute evenly on the
data. Formally, let multi-set Dk = {(x1k , h1 ), (x2k , h2 ) Â· Â· Â· (xnk , hn )}
represent the k-th feature values and second order gradient
statistics of each training instances. We can define a rank
functions rk : R â†’ [0, +âˆž) as
X
1
rk (z) = P
h,
(8)
(x,h)âˆˆDk h
(x,h)âˆˆDk ,x<z

tributed setting. To support effective gradient tree boosting
in these two settings, an approximate algorithm is needed.
We summarize an approximate framework, which resembles the ideas proposed in past literatures [17, 2, 22], in
Alg. 2. To summarize, the algorithm first proposes candidate splitting points according to percentiles of feature
distribution (a specific criteria will be given in Sec. 3.3).
The algorithm then maps the continuous features into buckets split by these candidate points, aggregates the statistics
and finds the best solution among proposals based on the
aggregated statistics.
There are two variants of the algorithm, depending on
when the proposal is given. The global variant proposes all
the candidate splits during the initial phase of tree construction, and uses the same proposals for split finding at all levels. The local variant re-proposes after each split. The global
method requires less proposal steps than the local method.
However, usually more candidate points are needed for the
global proposal because candidates are not refined after each
split. The local proposal refines the candidates after splits,
and can potentially be more appropriate for deeper trees. A
comparison of different algorithms on a Higgs boson dataset
is given by Fig. 3. We find that the local proposal indeed
requires fewer candidates. The global proposal can be as
accurate as the local one given enough candidates.
Most existing approximate algorithms for distributed tree
learning also follow this framework. Notably, it is also possible to directly construct approximate histograms of gradient
statistics [22]. It is also possible to use other variants of binning strategies instead of quantile [17]. Quantile strategy
benefit from being distributable and recomputable, which
we will detail in next subsection. From Fig. 3, we also find
that the quantile strategy can get the same accuracy as exact
greedy given reasonable approximation level.
Our system efficiently supports exact greedy for the single
machine setting, as well as approximate algorithm with both
local and global proposal methods for all settings. Users can
freely choose between the methods according to their needs.

3.3

Weighted Quantile Sketch

One important step in the approximate algorithm is to
propose candidate split points. Usually percentiles of a fea-

which represents the proportion of instances whose feature
value k is smaller than z. The goal is to find candidate split
points {sk1 , sk2 , Â· Â· Â· skl }, such that
|rk (sk,j ) âˆ’ rk (sk,j+1 )| < , sk1 = min xik , skl = max xik .
i

i

(9)
Here  is an approximation factor. Intuitively, this means
that there is roughly 1/ candidate points. Here each data
point is weighted by hi . To see why hi represents the weight,
we can rewrite Eq (3) as
n
X

1
hi (ft (xi ) âˆ’ gi /hi )2 + â„¦(ft ) + constant,
2
i=1

which is exactly weighted squared loss with labels gi /hi
and weights hi . For large datasets, it is non-trivial to find
candidate splits that satisfy the criteria. When every instance has equal weights, an existing algorithm called quantile sketch [14, 24] solves the problem. However, there is no
existing quantile sketch for the weighted datasets. Therefore, most existing approximate algorithms either resorted
to sorting on a random subset of data which have a chance of
failure or heuristics that do not have theoretical guarantee.
To solve this problem, we introduced a novel distributed
weighted quantile sketch algorithm that can handle weighted
data with a provable theoretical guarantee. The general idea
is to propose a data structure that supports merge and prune
operations, with each operation proven to maintain a certain
accuracy level. A detailed description of the algorithm as
well as proofs are given in the appendix.

3.4

Sparsity-aware Split Finding

In many real-world problems, it is quite common for the
input x to be sparse. There are multiple possible causes
for sparsity: 1) presence of missing values in the data; 2)
frequent zero entries in the statistics; and, 3) artifacts of
feature engineering such as one-hot encoding. It is important to make the algorithm aware of the sparsity pattern in
the data. In order to do so, we propose to add a default
direction in each tree node, which is shown in Fig. 4. When
a value is missing in the sparse matrix x, the instance is
classified into the default direction. There are two choices

Figure 6: Block structure for parallel learning. Each column in a block is sorted by the corresponding feature
value. A linear scan over one column in the block is sufficient to enumerate all the split points.

of default direction in each branch. The optimal default directions are learnt from the data. The algorithm is shown in
Alg. 3. The key improvement is to only visit the non-missing
entries Ik . The presented algorithm treats the non-presence
as a missing value and learns the best direction to handle
missing values. The same algorithm can also be applied
when the non-presence corresponds to a user specified value
by limiting the enumeration only to consistent solutions.
To the best of our knowledge, most existing tree learning algorithms are either only optimized for dense data, or
need specific procedures to handle limited cases such as categorical encoding. XGBoost handles all sparsity patterns in
a unified way. More importantly, our method exploits the
sparsity to make computation complexity linear to number
of non-missing entries in the input. Fig. 5 shows the comparison of sparsity aware and a naive implementation on an
Allstate-10K dataset (description of dataset given in Sec. 6).
We find that the sparsity aware algorithm runs 50 times
faster than the naive version. This confirms the importance
of the sparsity aware algorithm.

32
Basic algorithm

16
8
Time per Tree(sec)

Algorithm 3: Sparsity-aware Split Finding
Input: I, instance set of current node
Input: Ik = {i âˆˆ I|xik 6= missing}
Input: d, feature dimension
Also applies to the approximate setting, only collect
statistics of non-missing entries into buckets
gain â†
P0
P
G â† iâˆˆI , gi ,H â† iâˆˆI hi
for k = 1 to m do
// enumerate missing value goto right
GL â† 0, HL â† 0
for j in sorted(Ik , ascent order by xjk ) do
GL â† GL + gj , HL â† HL + hj
GR â† G âˆ’ GL , HR â† H âˆ’ HL
G2
G2
G2
score â† max(score, HLL+Î» + HRR+Î» âˆ’ H+Î»
)
end
// enumerate missing value goto left
GR â† 0, HR â† 0
for j in sorted(Ik , descent order by xjk ) do
GR â† GR + gj , HR â† HR + hj
GL â† G âˆ’ GR , HL â† H âˆ’ HR
G2
G2
G2
score â† max(score, HLL+Î» + HRR+Î» âˆ’ H+Î»
)
end
end
Output: Split and default directions with max gain

4
2
1
0.5
Sparsity aware algorithm

0.25
0.125
0.0625
0.03125

1

2

8
4
Number of Threads

16

Figure 5: Impact of the sparsity aware algorithm
on Allstate-10K. The dataset is sparse mainly due
to one-hot encoding. The sparsity aware algorithm
is more than 50 times faster than the naive version
that does not take sparsity into consideration.

4.

SYSTEM DESIGN

4.1

Column Block for Parallel Learning

The most time consuming part of tree learning is to get
the data into sorted order. In order to reduce the cost of
sorting, we propose to store the data in in-memory units,
which we called block. Data in each block is stored in the
compressed column (CSC) format, with each column sorted
by the corresponding feature value. This input data layout
only needs to be computed once before training, and can be
reused in later iterations.
In the exact greedy algorithm, we store the entire dataset
in a single block and run the split search algorithm by linearly scanning over the pre-sorted entries. We do the split
finding of all leaves collectively, so one scan over the block
will collect the statistics of the split candidates in all leaf
branches. Fig. 6 shows how we transform a dataset into the
format and find the optimal split using the block structure.
The block structure also helps when using the approximate algorithms. Multiple blocks can be used in this case,
with each block corresponding to subset of rows in the dataset.
Different blocks can be distributed across machines, or stored
on disk in the out-of-core setting. Using the sorted structure, the quantile finding step becomes a linear scan over
the sorted columns. This is especially valuable for local proposal algorithms, where candidates are generated frequently
at each branch. The binary search in histogram aggregation
also becomes a linear time merge style algorithm.
Collecting statistics for each column can be parallelized,
giving us a parallel algorithm for split finding. Importantly,
the column block structure also supports column subsampling, as it is easy to select a subset of columns in a block.

16

64

32

2

8
4
Number of Threads

16

(a) Allstate 10M

8

1

2

8
4
Number of Threads

16

2

1

(b) Higgs 10M

0.25

Basic algorithm
Cache-aware algorithm

4

0.5

16

1

8

Basic algorithm
Cache-aware algorithm

4
Time per Tree(sec)

32

Basic algorithm
Cache-aware algorithm

128
Time per Tree(sec)

Time per Tree(sec)

64

8

8

256

Basic algorithm
Cache-aware algorithm

Time per Tree(sec)

128

2

1

0.5

1

2

8
4
Number of Threads

16

0.25

1

(c) Allstate 1M

2

8
4
Number of Threads

16

(d) Higgs 1M

Figure 7: Impact of cache-aware prefetching in exact greedy algorithm. We find that the cache-miss effect
impacts the performance on the large datasets (10 million instances). Using cache aware prefetching improves
the performance by factor of two when the dataset is large.
128

block size=2^12
block size=2^16
64

block size=2^20

Time Complexity Analysis Let d be the maximum depth
of the tree and K be total number of trees. For the exact greedy algorithm, the time complexity of original spase
aware algorithm is O(Kdkxk0 log n). Here we use kxk0 to
denote number of non-missing entries in the training data.
On the other hand, tree boosting on the block structure only
cost O(Kdkxk0 + kxk0 log n). Here O(kxk0 log n) is the one
time preprocessing cost that can be amortized. This analysis
shows that the block structure helps to save an additional
log n factor, which is significant when n is large. For the
approximate algorithm, the time complexity of original algorithm with binary search is O(Kdkxk0 log q). Here q is
the number of proposal candidates in the dataset. While q
is usually between 32 and 100, the log factor still introduces
overhead. Using the block structure, we can reduce the time
to O(Kdkxk0 + kxk0 log B), where B is the maximum number of rows in each block. Again we can save the additional
log q factor in computation.

4.2

Cache-aware Access

While the proposed block structure helps optimize the
computation complexity of split finding, the new algorithm
requires indirect fetches of gradient statistics by row index,
since these values are accessed in order of feature. This is
a non-continuous memory access. A naive implementation
of split enumeration introduces immediate read/write dependency between the accumulation and the non-continuous
memory fetch operation (see Fig. 8). This slows down split
finding when the gradient statistics do not fit into CPU cache
and cache miss occur.
For the exact greedy algorithm, we can alleviate the problem by a cache-aware prefetching algorithm. Specifically,
we allocate an internal buffer in each thread, fetch the gradient statistics into it, and then perform accumulation in
a mini-batch manner. This prefetching changes the direct
read/write dependency to a longer dependency and helps to
reduce the runtime overhead when number of rows in the
is large. Figure 7 gives the comparison of cache-aware vs.

16

8

4

1

2

8

4
Number of Threads

16

(a) Allstate 10M
512

block size=2^12
256

block size=2^16
block size=2^20

128
Time per Tree(sec)

Figure 8:
Short range data dependency pattern
that can cause stall due to cache miss.

Time per Tree(sec)

block size=2^24
32

block size=2^24

64

32

16

8

4

1

2

4
Number of Threads

8

16

(b) Higgs 10M
Figure 9: The impact of block size in the approximate algorithm. We find that overly small blocks results in inefficient parallelization, while overly large
blocks also slows down training due to cache misses.

non cache-aware algorithm on the the Higgs and the Allstate dataset. We find that cache-aware implementation of
the exact greedy algorithm runs twice as fast as the naive
version when the dataset is large.
For approximate algorithms, we solve the problem by choosing a correct block size. We define the block size to be maximum number of examples in contained in a block, as this
reflects the cache storage cost of gradient statistics. Choosing an overly small block size results in small workload for
each thread and leads to inefficient parallelization. On the
other hand, overly large blocks result in cache misses, as the
gradient statistics do not fit into the CPU cache. A good
choice of block size balances these two factors. We compared
various choices of block size on two data sets. The results
are given in Fig. 9. This result validates our discussion and

System
XGBoost
pGBRT
Spark MLLib
H2O
scikit-learn
R GBM

Table 1: Comparison of major tree boosting systems.
exact
approximate approximate
sparsity
out-of-core
greedy global
local
aware
yes
yes
yes
yes
yes
no
no
yes
no
no
no
yes
no
no
partially
no
yes
no
no
partially
yes
no
no
no
no
yes
no
no
no
partially

shows that choosing 216 examples per block balances the
cache property and parallelization.

4.3

Blocks for Out-of-core Computation

One goal of our system is to fully utilize a machineâ€™s resources to achieve scalable learning. Besides processors and
memory, it is important to utilize disk space to handle data
that does not fit into main memory. To enable out-of-core
computation, we divide the data into multiple blocks and
store each block on disk. During computation, it is important to use an independent thread to pre-fetch the block into
a main memory buffer, so computation can happen in concurrence with disk reading. However, this does not entirely
solve the problem since the disk reading takes most of the
computation time. It is important to reduce the overhead
and increase the throughput of disk IO. We mainly use two
techniques to improve the out-of-core computation.
Block Compression The first technique we use is block
compression. The block is compressed by columns, and decompressed on the fly by an independent thread when loading into main memory. This helps to trade some of the
computation in decompression with the disk reading cost.
We use a general purpose compression algorithm for compressing the features values. For the row index, we substract
the row index by the begining index of the block and use a
16bit integer to store each offset. This requires 216 examples
per block, which is confirmed to be a good setting. In most
of the dataset we tested, we achieve roughly a 26% to 29%
compression ratio.
Block Sharding The second technique is to shard the data
onto multiple disks in an alternative manner. A pre-fetcher
thread is assigned to each disk and fetches the data into an
in-memory buffer. The training thread then alternatively
reads the data from each buffer. This helps to increase the
throughput of disk reading when multiple disks are available.

5.

RELATED WORKS

Our system implements gradient boosting [10], which performs additive optimization in functional space. Gradient
tree boosting has been successfully used in classification [12],
learning to rank [5], structured prediction [8] as well as other
fields. XGBoost incorporates a regularized model to prevent
overfitting. This this resembles previous work on regularized
greedy forest [25], but simplifies the objective and algorithm
for parallelization. Column sampling is a simple but effective
technique borrowed from RandomForest [4]. While sparsityaware learning is essential in other types of models such as
linear models [9], few works on tree learning have considered
this topic in a principled way. The algorithm proposed in
this paper is the first unified approach to handle all kinds of
sparsity patterns.

parallel
yes
yes
yes
yes
no
no

There are several existing works on parallelizing tree learning [22, 19]. Most of these algorithms fall into the approximate framework described in this paper. Notably, it
is also possible to partition data by columns [23] and apply the exact greedy algorithm. This is also supported in
our framework, and the techniques such as cache-aware prefecthing can be used to benefit this type of algorithm. While
most existing works focus on the algorithmic aspect of parallelization, our work improves in two unexplored system directions: out-of-core computation and cache-aware learning.
This gives us insights on how the system and the algorithm
can be jointly optimized and provides an end-to-end system
that can handle large scale problems with very limited computing resources. We also summarize the comparison between our system and existing opensource implementations
in Table 1.
Quantile summary (without weights) is a classical problem in the database community [14, 24]. However, the approximate tree boosting algorithm reveals a more general
problem â€“ finding quantiles on weighted data. To the best
of our knowledge, the weighted quantile sketch proposed in
this paper is the first method to solve this problem. The
weighted quantile summary is also not specific to the tree
learning and can benefit other applications in data science
and machine learning in the future.

6.

END TO END EVALUATIONS

6.1

System Implementation

We implemented XGBoost as an open source package5 .
The package is portable and reusable. It supports various
weighted classification and rank objective functions, as well
as user defined objective function. It is available in popular
languages such as python, R, Julia and integrates naturally
with language native data science pipelines such as scikitlearn. The distributed version is built on top of the rabit
library6 for allreduce. The portability of XGBoost makes it
available in many ecosystems, instead of only being tied to
a specific platform. The distributed XGBoost runs natively
on Hadoop, MPI Sun Grid engine. Recently, we also enable
distributed XGBoost on jvm bigdata stacks such as Flink
and Spark. The distributed version has also been integrated
into cloud platform Tianchi7 of Alibaba. We believe that
there will be more integrations in the future.

6.2
5

Dataset and Setup

https://github.com/dmlc/xgboost
https://github.com/dmlc/rabit
7
https://tianchi.aliyun.com
6

We used four datasets in our experiments. A summary of
these datasets is given in Table 2. In some of the experiments, we use a randomly selected subset of the data either
due to slow baselines or to demonstrate the performance of
the algorithm with varying dataset size. We use a suffix to
denote the size in these cases. For example Allstate-10K
means a subset of the Allstate dataset with 10K instances.
The first dataset we use is the Allstate insurance claim
dataset8 . The task is to predict the likelihood and cost of
an insurance claim given different risk factors. In the experiment, we simplified the task to only predict the likelihood
of an insurance claim. This dataset is used to evaluate the
impact of sparsity-aware algorithm in Sec. 3.4. Most of the
sparse features in this data come from one-hot encoding. We
randomly select 10M instances as training set and use the
rest as evaluation set.
The second dataset is the Higgs boson dataset9 from high
energy physics. The data was produced using Monte Carlo
simulations of physics events. It contains 21 kinematic properties measured by the particle detectors in the accelerator.
It also contains seven additional derived physics quantities
of the particles. The task is to classify whether an event
corresponds to the Higgs boson. We randomly select 10M
instances as training set and use the rest as evaluation set.
The third dataset is the Yahoo! learning to rank challenge
dataset [6], which is one of the most commonly used benchmarks in learning to rank algorithms. The dataset contains
20K web search queries, with each query corresponding to a
list of around 22 documents. The task is to rank the documents according to relevance of the query. We use the official
train test split in our experiment.
The last dataset is the criteo terabyte click log dataset10 .
We use this dataset to evaluate the scaling property of the
system in the out-of-core and the distributed settings. The
data contains 13 integer features and 26 ID features of user,
item and advertiser information. Since a tree based model
is better at handling continuous features, we preprocess the
data by calculating the statistics of average CTR and count
of ID features on the first ten days, replacing the ID features by the corresponding count statistics during the next
ten days for training. The training set after preprocessing
contains 1.7 billion instances with 67 features (13 integer, 26
average CTR statistics and 26 counts). The entire dataset
is more than one terabyte in LibSVM format.
We use the first three datasets for the single machine parallel setting, and the last dataset for the distributed and
out-of-core settings. All the single machine experiments are
conducted on a Dell PowerEdge R420 with two eight-core
Intel Xeon (E5-2470) (2.3GHz) and 64GB of memory. If
not specified, all the experiments are run using all the avail8

https://www.kaggle.com/c/ClaimPredictionChallenge
https://archive.ics.uci.edu/ml/datasets/HIGGS
10
http://labs.criteo.com/downloads/download-terabyteclick-logs/

Table 3: Comparison of Exact Greedy Methods with
500 trees on Higgs-1M data.
Method
Time per Tree (sec) Test AUC
XGBoost
0.6841
0.8304
XGBoost (colsample=0.5)
0.6401
0.8245
scikit-learn
28.51
0.8302
R.gbm
1.032
0.6224
32
16
Time per Tree(sec)

Table 2: Dataset used in the Experiments.
Dataset
n
m
Task
Allstate
10 M 4227 Insurance claim classification
Higgs Boson
10 M
28
Event classification
Yahoo LTRC 473K
700
Learning to Rank
Criteo
1.7 B
67
Click through rate prediction

pGBRT

8
4

XGBoost

2
1
0.5

1

2

8
4
Number of Threads

16

Figure 10: Comparison between XGBoost and pGBRT on Yahoo LTRC dataset.
Table 4: Comparison of Learning to Rank with 500
trees on Yahoo! LTRC Dataset
Method
Time per Tree (sec) NDCG@10
XGBoost
0.826
0.7892
XGBoost (colsample=0.5)
0.506
0.7913
pGBRT [22]
2.576
0.7915

able cores in the machine. The machine settings of the distributed and the out-of-core experiments will be described in
the corresponding section. In all the experiments, we boost
trees with a common setting of maximum depth equals 8,
shrinkage equals 0.1 and no column subsampling unless explicitly specified. We can find similar results when we use
other settings of maximum depth.

6.3

Classification

In this section, we evaluate the performance of XGBoost
on a single machine using the exact greedy algorithm on
Higgs-1M data, by comparing it against two other commonly
used exact greedy tree boosting implementations. Since
scikit-learn only handles non-sparse input, we choose the
dense Higgs dataset for a fair comparison. We use the 1M
subset to make scikit-learn finish running in reasonable time.
Among the methods in comparison, Râ€™s GBM uses a greedy
approach that only expands one branch of a tree, which
makes it faster but can result in lower accuracy, while both
scikit-learn and XGBoost learn a full tree. The results are
shown in Table 3. Both XGBoost and scikit-learn give better
performance than Râ€™s GBM, while XGBoost runs more than
10x faster than scikit-learn. In this experiment, we also find
column subsamples gives slightly worse performance than
using all the features. This could due to the fact that there
are few important features in this dataset and we can benefit
from greedily select from all the features.

9

6.4

Learning to Rank

We next evaluate the performance of XGBoost on the

4096

32768

Block compression

16384

1024

Basic algorithm

512

Compression+shard
Out of system file cache
start from this point

Total Running Time (sec)

Time per Tree(sec)

2048

256

8192
4096
Spark MLLib

2048
1024
512

XGBoost

256
128
128

256
512
1024
2048
Number of Training Examples (million)

Figure 11: Comparison of out-of-core methods on
different subsets of criteo data. The missing data
points are due to out of disk space. We can find
that basic algorithm can only handle 200M examples. Adding compression gives 3x speedup, and
sharding into two disks gives another 2x speedup.
The system runs out of file cache start from 400M
examples. The algorithm really has to rely on disk
after this point. The compression+shard method
has a less dramatic slowdown when running out of
file cache, and exhibits a linear trend afterwards.

256
512
1024
Number of Training Examples (million)

2048

(a) End-to-end time cost include data loading
4096
2048
1024
Time per Iteration (sec)

128
128

H2O

512
256
Spark MLLib

128
64

H2O

32

learning to rank problem. We compare against pGBRT [22],
the best previously pubished system on this task. XGBoost
runs exact greedy algorithm, while pGBRT only support an
approximate algorithm. The results are shown in Table 4
and Fig. 10. We find that XGBoost runs faster. Interestingly, subsampling columns not only reduces running time,
and but also gives a bit higher performance for this problem. This could due to the fact that the subsampling helps
prevent overfitting, which is observed by many of the users.

6.5

Out-of-core Experiment

We also evaluate our system in the out-of-core setting on
the criteo data. We conducted the experiment on one AWS
c3.8xlarge machine (32 vcores, two 320 GB SSD, 60 GB
RAM). The results are shown in Figure 11. We can find
that compression helps to speed up computation by factor of
three, and sharding into two disks further gives 2x speedup.
For this type of experiment, it is important to use a very
large dataset to drain the system file cache for a real outof-core setting. This is indeed our setup. We can observe a
transition point when the system runs out of file cache. Note
that the transition in the final method is less dramatic. This
is due to larger disk throughput and better utilization of
computation resources. Our final method is able to process
1.7 billion examples on a single machine.

6.6

Distributed Experiment

Finally, we evaluate the system in the distributed setting.
We set up a YARN cluster on EC2 with m3.2xlarge machines, which is a very common choice for clusters. Each
machine contains 8 virtual cores, 30GB of RAM and two
80GB SSD local disks. The dataset is stored on AWS S3
instead of HDFS to avoid purchasing persistent storage.
We first compare our system against two production-level
distributed systems: Spark MLLib [18] and H2O 11 . We use
11

www.h2o.ai

16
8
128

XGBoost

256
512
1024
Number of Training Examples (million)

2048

(b) Per iteration cost exclude data loading
Figure 12: Comparison of different distributed systems on 32 EC2 nodes for 10 iterations on different
subset of criteo data. XGBoost runs more 10x than
spark per iteration and 2.2x as H2Oâ€™s optimized version (However, H2O is slow in loading the data, getting worse end-to-end time). Note that spark suffers
from drastic slow down when running out of memory. XGBoost runs faster and scales smoothly to
the full 1.7 billion examples with given resources by
utilizing out-of-core computation.
32 m3.2xlarge machines and test the performance of the systems with various input size. Both of the baseline systems
are in-memory analytics frameworks that need to store the
data in RAM, while XGBoost can switch to out-of-core setting when it runs out of memory. The results are shown
in Fig. 12. We can find that XGBoost runs faster than the
baseline systems. More importantly, it is able to take advantage of out-of-core computing and smoothly scale to all
1.7 billion examples with the given limited computing resources. The baseline systems are only able to handle subset of the data with the given resources. This experiment
shows the advantage to bring all the system improvement
together and solve a real-world scale problem. We also evaluate the scaling property of XGBoost by varying the number
of machines. The results are shown in Fig. 13. We can find
XGBoostâ€™s performance scales linearly as we add more machines. Importantly, XGBoost is able to handle the entire
1.7 billion data with only four machines. This shows the
systemâ€™s potential to handle even larger data.

2048

Time per Iteration (sec)

1024

512

256

128

4

8
16
Number of Machines

32

Figure 13: Scaling of XGBoost with different number of machines on criteo full 1.7 billion dataset.
Using more machines results in more file cache and
makes the system run faster, causing the trend
to be slightly super linear. XGBoost can process
the entire dataset using as little as four machines,
and scales smoothly by utilizing more available resources.

7.

CONCLUSION

In this paper, we described the lessons we learnt when
building XGBoost, a scalable tree boosting system that is
widely used by data scientists and provides state-of-the-art
results on many problems. We proposed a novel sparsity
aware algorithm for handling sparse data and a theoretically
justified weighted quantile sketch for approximate learning.
Our experience shows that cache access patterns, data compression and sharding are essential elements for building a
scalable end-to-end system for tree boosting. These lessons
can be applied to other machine learning systems as well.
By combining these insights, XGBoost is able to solve realworld scale problems using a minimal amount of resources.

Acknowledgments
We would like to thank Tyler B. Johnson, Marco Tulio Ribeiro,
Sameer Singh, Arvind Krishnamurthy for their valuable feedback.
We also sincerely thank Tong He, Bing Xu, Michael Benesty, Yuan
Tang, Hongliang Liu, Qiang Kou, Nan Zhu and all other contributors in the XGBoost community. This work was supported
in part by ONR (PECASE) N000141010672, NSF IIS 1258741
and the TerraSwarm Research Center sponsored by MARCO and
DARPA.

8.

REFERENCES

[1] R. Bekkerman. The present and the future of the kdd cup
competition: an outsiderâ€™s perspective.
[2] R. Bekkerman, M. Bilenko, and J. Langford. Scaling Up
Machine Learning: Parallel and Distributed Approaches.
Cambridge University Press, New York, NY, USA, 2011.
[3] J. Bennett and S. Lanning. The netflix prize. In
Proceedings of the KDD Cup Workshop 2007, pages 3â€“6,
New York, Aug. 2007.
[4] L. Breiman. Random forests. Maching Learning,
45(1):5â€“32, Oct. 2001.
[5] C. Burges. From ranknet to lambdarank to lambdamart:
An overview. Learning, 11:23â€“581, 2010.
[6] O. Chapelle and Y. Chang. Yahoo! Learning to Rank
Challenge Overview. Journal of Machine Learning
Research - W & CP, 14:1â€“24, 2011.
[7] T. Chen, H. Li, Q. Yang, and Y. Yu. General functional
matrix factorization using gradient boosting. In Proceeding

of 30th International Conference on Machine Learning
(ICMLâ€™13), volume 1, pages 436â€“444, 2013.
[8] T. Chen, S. Singh, B. Taskar, and C. Guestrin. Efficient
second-order gradient boosting for conditional random
fields. In Proceeding of 18th Artificial Intelligence and
Statistics Conference (AISTATSâ€™15), volume 1, 2015.
[9] R.-E. Fan, K.-W. Chang, C.-J. Hsieh, X.-R. Wang, and
C.-J. Lin. LIBLINEAR: A library for large linear
classification. Journal of Machine Learning Research,
9:1871â€“1874, 2008.
[10] J. Friedman. Greedy function approximation: a gradient
boosting machine. Annals of Statistics, 29(5):1189â€“1232,
2001.
[11] J. Friedman. Stochastic gradient boosting. Computational
Statistics & Data Analysis, 38(4):367â€“378, 2002.
[12] J. Friedman, T. Hastie, and R. Tibshirani. Additive logistic
regression: a statistical view of boosting. Annals of
Statistics, 28(2):337â€“407, 2000.
[13] J. H. Friedman and B. E. Popescu. Importance sampled
learning ensembles, 2003.
[14] M. Greenwald and S. Khanna. Space-efficient online
computation of quantile summaries. In Proceedings of the
2001 ACM SIGMOD International Conference on
Management of Data, pages 58â€“66, 2001.
[15] X. He, J. Pan, O. Jin, T. Xu, B. Liu, T. Xu, Y. Shi,
A. Atallah, R. Herbrich, S. Bowers, and J. Q. n. Candela.
Practical lessons from predicting clicks on ads at facebook.
In Proceedings of the Eighth International Workshop on
Data Mining for Online Advertising, ADKDDâ€™14, 2014.
[16] P. Li. Robust Logitboost and adaptive base class (ABC)
Logitboost. In Proceedings of the Twenty-Sixth Conference
Annual Conference on Uncertainty in Artificial Intelligence
(UAIâ€™10), pages 302â€“311, 2010.
[17] P. Li, Q. Wu, and C. J. Burges. Mcrank: Learning to rank
using multiple classification and gradient boosting. In
Advances in Neural Information Processing Systems 20,
pages 897â€“904. 2008.
[18] X. Meng, J. Bradley, B. Yavuz, E. Sparks,
S. Venkataraman, D. Liu, J. Freeman, D. Tsai, M. Amde,
S. Owen, D. Xin, R. Xin, M. J. Franklin, R. Zadeh,
M. Zaharia, and A. Talwalkar. MLlib: Machine learning in
apache spark. Journal of Machine Learning Research,
17(34):1â€“7, 2016.
[19] B. Panda, J. S. Herbach, S. Basu, and R. J. Bayardo.
Planet: Massively parallel learning of tree ensembles with
mapreduce. Proceeding of VLDB Endowment,
2(2):1426â€“1437, Aug. 2009.
[20] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel,
B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer,
R. Weiss, V. Dubourg, J. Vanderplas, A. Passos,
D. Cournapeau, M. Brucher, M. Perrot, and E. Duchesnay.
Scikit-learn: Machine learning in Python. Journal of
Machine Learning Research, 12:2825â€“2830, 2011.
[21] G. Ridgeway. Generalized Boosted Models: A guide to the
gbm package.
[22] S. Tyree, K. Weinberger, K. Agrawal, and J. Paykin.
Parallel boosted regression trees for web search ranking. In
Proceedings of the 20th international conference on World
wide web, pages 387â€“396. ACM, 2011.
[23] J. Ye, J.-H. Chow, J. Chen, and Z. Zheng. Stochastic
gradient boosted distributed decision trees. In Proceedings
of the 18th ACM Conference on Information and
Knowledge Management, CIKM â€™09.
[24] Q. Zhang and W. Wang. A fast algorithm for approximate
quantiles in high speed data streams. In Proceedings of the
19th International Conference on Scientific and Statistical
Database Management, 2007.
[25] T. Zhang and R. Johnson. Learning nonlinear functions
using regularized greedy forest. IEEE Transactions on
Pattern Analysis and Machine Intelligence, 36(5), 2014.

APPENDIX
A.

+
âˆ’
2) rÌƒD
, rÌƒD
and Ï‰ÌƒD are functions in S â†’ [0, +âˆž), that satisfies

WEIGHTED QUANTILE SKETCH

âˆ’
âˆ’
+
+
rÌƒD
(xi ) â‰¤ rD
(xi ), rÌƒD
(xi ) â‰¥ rD
(xi ), Ï‰ÌƒD (xi ) â‰¤ Ï‰D (xi ),

In this section, we introduce the weighted quantile sketch algorithm. Approximate answer of quantile queries is for many realworld applications. One classical approach to this problem is GK
algorithm [14] and extensions based on the GK framework [24].
The main component of these algorithms is a data structure called
quantile summary, that is able to answer quantile queries with
relative accuracy of . Two operations are defined for a quantile
summary:
â€¢ A merge operation that combines two summaries with approximation error 1 and 2 together and create a merged
summary with approximation error max(1 , 2 ).
â€¢ A prune operation that reduces the number of elements in
the summary to b + 1 and changes approximation error from
 to  + 1b .
A quantile summary with merge and prune operations forms basic
building blocks of the distributed and streaming quantile computing algorithms [24].
In order to use quantile computation for approximate tree boosting, we need to find quantiles on weighted data. This more general problem is not supported by any of the existing algorithm. In
this section, we describe a non-trivial weighted quantile summary
structure to solve this problem. Importantly, the new algorithm
contains merge and prune operations with the same guarantee as
GK summary. This allows our summary to be plugged into all
the frameworks used GK summary as building block and answer
quantile queries over weighted data efficiently.

A.1

Given an input multi-set D = {(x1 , w1 ), (x2 , w2 ) Â· Â· Â· (xn , wn )}
such that wi âˆˆ [0, +âˆž), xi âˆˆ X . Each xi corresponds to a position of the point and wi is the weight of the point. Assume
we have a total order < defined on X . Let us define two rank
âˆ’ +
functions rD
, rD : X â†’ [0, +âˆž)
âˆ’
rD
(y) =

X

w

(10)

+
rD
(y) =

âˆ’
âˆ’
+
+
rÌƒD
(xi ) + Ï‰ÌƒD (xi ) â‰¤ rÌƒD
(xi+1 ), rÌƒD
(xi ) â‰¤ rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 )
(15)

Since these functions are only defined on S, it is suffice to use 4k
record to store the summary. Specifically, we need to remember
each xi and the corresponding function values of each xi .
Definition A.2. Extension of Function Domains
+ âˆ’
Given a quantile summary Q(D) = (S, rÌƒD
, rÌƒD , Ï‰ÌƒD ) defined in
+
âˆ’
Definition A.1, the domain of rÌƒD , rÌƒD and Ï‰ÌƒD were defined only
in S. We extend the definition of these functions to X â†’ [0, +âˆž)
as follows
When y < x1 :
âˆ’
+
rÌƒD
(y) = 0, rÌƒD
(y) = 0, Ï‰ÌƒD (y) = 0

(16)

âˆ’
+
+
+
rÌƒD
(y) = rÌƒD
(xk ), rÌƒD
(y) = rÌƒD
(xk ), Ï‰ÌƒD (y) = 0

(17)

When y > xk :

When y âˆˆ (xi , xi+1 ) for some i:
âˆ’
âˆ’
rÌƒD
(y) = rÌƒD
(xi ) + Ï‰ÌƒD (xi ),

w

(11)

(x,w)âˆˆD,xâ‰¤y

We should note that since D is defined to be a multiset of the
points. It can contain multiple record with exactly same position
x and weight w. We also define another weight function Ï‰D :
X â†’ [0, +âˆž) as

(18)

Ï‰ÌƒD (y) = 0
Lemma A.1. Extended Constraint
âˆ’
+
The extended definition of rÌƒD
, rÌƒD
, Ï‰ÌƒD satisfies the following
constraints
âˆ’
âˆ’
+
+
rÌƒD
(y) â‰¤ rD
(y), rÌƒD
(y) â‰¥ rD
(y), Ï‰ÌƒD (y) â‰¤ Ï‰D (y)
âˆ’
âˆ’
rÌƒD
(y) + Ï‰ÌƒD (y) â‰¤ rÌƒD
(x),

(x,w)âˆˆD,x<y

X

Finally, the function value must also satisfy the following constraints

+
+
rÌƒD
(y) = rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 ),

Formalization and Definitions

(14)

âˆ’
the equality sign holds for maximum and minimum point ( rÌƒD
(xi ) =
âˆ’
+
+
rD (xi ), rÌƒD (xi ) = rD (xi ) and Ï‰ÌƒD (xi ) = Ï‰D (xi ) for i âˆˆ {1, k}).

+
+
rÌƒD
(y) â‰¤ rÌƒD
(x) âˆ’ Ï‰ÌƒD (x),

(19)

for all y < x
(20)

Proof. The only non-trivial part is to prove the case when
y âˆˆ (xi , xi+1 ):
âˆ’
âˆ’
âˆ’
âˆ’
rÌƒD
(y) = rÌƒD
(xi ) + Ï‰ÌƒD (xi ) â‰¤ rD
(xi ) + Ï‰D (xi ) â‰¤ rD
(y)
+
+
+
+
rÌƒD
(y) = rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 ) â‰¥ rD
(xi+1 ) âˆ’ Ï‰D (xi+1 ) â‰¥ rD
(y)

This proves Eq. (19). Furthermore, we can verify that
+
âˆ’
Ï‰D (y) = rD
(y) âˆ’ rD
(y) =

X

w.

(12)

(x,w)âˆˆD,x=y

Finally, we also define the weight of multi-set D to be the sum of
weights of all the points in the set
Ï‰(D) =

X

w

(13)

+
+
+
rÌƒD
(xi ) â‰¤ rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 ) = rÌƒD
(y) âˆ’ Ï‰ÌƒD (y)
âˆ’
âˆ’
âˆ’
rÌƒD
(y) + Ï‰ÌƒD (y) = rÌƒD
(xi ) + Ï‰ÌƒD (xi ) + 0 â‰¤ rÌƒD
(xi+1 )
+
+
rÌƒD
(y) = rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 )

Using these facts and transitivity of < relation, we can prove
Eq. (20)

(x,w)âˆˆD

Our task is given a series of input D, to estimate r+ (y) and râˆ’ (y)
for y âˆˆ X as well as finding points with specific rank. Given these
notations, we define quantile summary of weighted examples as
follows:

We should note that the extension is based on the ground case
defined in S, and we do not require extra space to store the summary in order to use the extended definition. We are now ready
to introduce the definition of -approximate quantile summary.
Definition A.3. -Approximate Quantile Summary
+ âˆ’
Given a quantile summary Q(D) = (S, rÌƒD
, rÌƒD , Ï‰ÌƒD ), we call it is
-approximate summary if for any y âˆˆ X

Definition A.1. Quantile Summary of Weighted Data
+ âˆ’
A quantile summary for D is defined to be tuple Q(D) = (S, rÌƒD
, rÌƒD , Ï‰ÌƒD ),
+
âˆ’
where S = {x1 , x2 , Â· Â· Â· , xk } is selected from the points in D (i.e.
rÌƒD
(y) âˆ’ rÌƒD
(y) âˆ’ Ï‰ÌƒD (y) â‰¤ Ï‰(D)
(21)
xi âˆˆ {x|(x, w) âˆˆ D}) with the following properties:
âˆ’
+
âˆ’
1) xi < xi+1 for all i, and x1 and xk are minimum and maxWe use this definition since we know that r (y) âˆˆ [rÌƒD (y), rÌƒD (y)âˆ’
âˆ’
+
imum point in D:
Ï‰ÌƒD (y)] and r+ (y) âˆˆ [rÌƒD
(y) + Ï‰ÌƒD (y), rÌƒD
(y)]. Eq. (21) means the
+
we can get estimation of r (y) and râˆ’ (y) by error of at most
x1 = min x, xk = max x
Ï‰(D).
(x,w)âˆˆD
(x,w)âˆˆD

+ âˆ’
Lemma A.2. Quantile summary Q(D) = (S, rÌƒD
, rÌƒD , Ï‰ÌƒD ) is an
-approximate summary if and only if the following two condition
holds
+
âˆ’
rÌƒD
(xi ) âˆ’ rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (xi ) â‰¤ Ï‰(D)
(22)
+
âˆ’
rÌƒD
(xi+1 ) âˆ’ rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (xi+1 ) âˆ’ Ï‰ÌƒD (xi ) â‰¤ Ï‰(D)

(23)

Proof. The key is again consider y âˆˆ (xi , xi+1 )
+
âˆ’
+
+
rÌƒD
(y)âˆ’rÌƒD
(y)âˆ’Ï‰ÌƒD (y) = [rÌƒD
(xi+1 )âˆ’Ï‰ÌƒD (xi+1 )]âˆ’[rÌƒD
(xi )+Ï‰ÌƒD (xi )]âˆ’0

This means the condition in Eq. (23) plus Eq.(22) can give us
Eq. (21)
Property of Extended Function In this section, we have in+ âˆ’
troduced the extension of function rÌƒD
, rÌƒD , Ï‰ÌƒD to X â†’ [0, +âˆž).
The key theme discussed in this section is the relation of constraints on the original function and constraints on the extended
function. Lemma A.1 and A.2 show that the constraints on the
original function can lead to in more general constraints on the
extended function. This is a very useful property which will be
used in the proofs in later sections.

A.2

Construction of Initial Summary

Given a small multi-set D = {(x1 , w1 ), (x2 , w2 ), Â· Â· Â· , (xn , wn )},
+ âˆ’
we can construct initial summary Q(D) = {S, rÌƒD
, rÌƒD , Ï‰ÌƒD }, with S
+ âˆ’
to the set of all values in D (S = {x|(x, w) âˆˆ D}), and rÌƒD
, rÌƒD , Ï‰ÌƒD
defined to be
+
+
âˆ’
âˆ’
rÌƒD
(x) = rD
(x), rÌƒD
(x) = rD
(x), Ï‰ÌƒD (x) = Ï‰D (x) for x âˆˆ S
(24)
The constructed summary is 0-approximate summary, since it can
answer all the queries accurately. The constructed summary can
be feed into future operations described in the latter sections.

A.3

Input: d: 0 â‰¤ d â‰¤ Ï‰(D)
+
âˆ’
Input: Q(D) = (S, rÌƒD
, rÌƒD
, Ï‰ÌƒD ) where
S = x1 , x2 , Â· Â· Â· , xk
âˆ’
+
(x1 ) + rÌƒD
(x1 )] then return x1 ;
if d < 12 [rÌƒD
+
1 âˆ’
if d â‰¥ 2 [rÌƒD (xk ) + rÌƒD
(xk )] then return xk ;
Find i such that
+
âˆ’
+
1 âˆ’
[rÌƒ (xi ) + rÌƒD
(xi )] â‰¤ d < 12 [rÌƒD
(xi+1 ) + rÌƒD
(xi+1 )]
2 D
âˆ’
+
if 2d < rÌƒD (xi ) + Ï‰ÌƒD (xi ) + rÌƒD (xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 ) then
return xi
else
return xi+1
end

This can be obtained by straight-forward application of Definition A.2.
Theorem A.1. If Q(D1 ) is 1 -approximate summary, and Q(D2 )
is 2 -approximate summary. Then the merged summary Q(D) is
max(1 , 2 )-approximate summary.
Proof. For any y âˆˆ X , we have
+
âˆ’
rÌƒD
(y) âˆ’ rÌƒD
(y) âˆ’ Ï‰ÌƒD (y)
+
+
âˆ’
âˆ’
=[rÌƒD
(y) + rÌƒD
(y)] âˆ’ [rÌƒD
(y) + rÌƒD
(y)] âˆ’ [Ï‰ÌƒD1 (y) + Ï‰ÌƒD2 (y)]
1
2
1
2

â‰¤1 Ï‰(D1 ) + 2 Ï‰(D2 ) â‰¤ max(1 , 2 )Ï‰(D1 âˆª D2 )
Here the first inequality is due to Lemma A.3.

A.4

Merge Operation

In this section, we define how we can merge the two summaries
+
âˆ’
together. Assume we have Q(D1 ) = (S1 , rÌƒD
, rÌƒD
, Ï‰ÌƒD1 ) and
1
1
+
âˆ’
Q(D2 ) = (S2 , rÌƒD
, rÌƒD
, Ï‰ÌƒD2 ) quantile summary of two dataset
1
2
D1 and D2 . Let D = D1 âˆª D2 , and define the merged summary
+ âˆ’
Q(D) = (S, rÌƒD
, rÌƒD , Ï‰ÌƒD ) as follows.

S = {x1 , x2 Â· Â· Â· , xk }, xi âˆˆ S1 or xi âˆˆ S2

Algorithm 4: Query Function g(Q, d)

(25)

Prune Operation

Before we start discussing the prune operation, we first introduce a query function g(Q, d). The definition of function is
shown in Algorithm 4. For a given rank d, the function returns
a x whose rank is close to d. This property is formally described
in the following Lemma.
Lemma A.4. For a given -approximate summary Q(D) =
+ âˆ’
(S, rÌƒD
, rÌƒD , Ï‰ÌƒD ), xâˆ— = g(Q, d) satisfies the following property

Ï‰(D)
2

âˆ’ âˆ—
d â‰¤ rÌƒD
(x ) + Ï‰ÌƒD (xâˆ— ) + Ï‰(D)
2

The points in S are combination of points in S1 and S2 . And the
+ âˆ’
function rÌƒD
, rÌƒD , Ï‰ÌƒD are defined to be
âˆ’
âˆ’
âˆ’
rÌƒD
(xi ) = rÌƒD
(xi ) + rÌƒD
(xi )
1
2

(26)

+
+
+
rÌƒD
(xi ) = rÌƒD
(xi ) + rÌƒD
(xi )
1
2

(27)

Ï‰ÌƒD (xi ) = Ï‰ÌƒD1 (xi ) + Ï‰ÌƒD2 (xi )
(28)
Here we use functions defined on S â†’ [0, +âˆž) on the left sides of
equalities and use the extended function definitions on the right
sides.
Due to additive nature of r+ , râˆ’ and Ï‰, which can be formally
written as

âˆ’
+
â€¢ d < 12 [rÌƒD
(x1 ) + rÌƒD
(x1 )] and xâˆ— = x1 . Note that the rank
+
information for x1 is accurate (Ï‰ÌƒD (x1 ) = rÌƒD
(x1 ) = Ï‰(x1 ),
âˆ’
rÌƒD (x1 ) = 0), we have

dâ‰¥0âˆ’

âˆ’
+
= rÌƒD
(x1 ) + Ï‰ÌƒD
(x1 )

Ï‰D (y) =Ï‰D1 (y) + Ï‰D2 (y),

âˆ’
+
â€¢ d â‰¥ 12 [rÌƒD
(xk ) + rÌƒD
(xk )] and xâˆ— = xk , then

1 âˆ’
+
[rÌƒ (xk ) + rÌƒD
(xk )]
2 D
1 +
+
âˆ’
= rÌƒD
(xk ) âˆ’ [rÌƒD
(xk ) âˆ’ rÌƒD
(xk )]
2
1
+
= rÌƒD
(xk ) âˆ’ Ï‰ÌƒD (xk )
2


âˆ’
d < Ï‰(D) + Ï‰(D) = rÌƒD
(xk ) + Ï‰ÌƒD (xk ) + Ï‰(D)
2
2

dâ‰¥
Lemma A.3. The combined quantile summary satisfies

for all y âˆˆ X



+
Ï‰(D) = rÌƒD
(x1 ) âˆ’ Ï‰ÌƒD (x1 ) âˆ’ Ï‰(D)
2
2

1 âˆ’
+
[rÌƒ (x1 ) + rÌƒD
(x1 )]
2 D
âˆ’
+
â‰¤ rÌƒD (x1 ) + rÌƒD (x1 )

(29)

and the extended constraint property in Lemma A.1, we can verify
that Q(D) satisfies all the constraints in Definition A.1. Therefore
it is a valid quantile summary.

âˆ’
âˆ’
âˆ’
rÌƒD
(y) = rÌƒD
(y) + rÌƒD
(y)
1
2

(30)

+
+
+
rÌƒD
(y) = rÌƒD
(y) + rÌƒD
(y)
1
2

(31)

Ï‰ÌƒD (y) = Ï‰ÌƒD1 (y) + Ï‰ÌƒD2 (y)

(32)

(33)

Proof. We need to discuss four possible cases

d<

âˆ’
âˆ’
âˆ’
rD
(y) =rD
(y) + rD
(y),
1
2
+
+
+
rD
(y) =rD
(y) + rD
(y),
1
2

+ âˆ—
d â‰¥ rÌƒD
(x ) âˆ’ Ï‰ÌƒD (xâˆ— ) âˆ’

â€¢ xâˆ— = xi in the general case, then
âˆ’
+
2d < rÌƒD
(xi ) + Ï‰ÌƒD (xi ) + rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 )
âˆ’
+
âˆ’
= 2[rÌƒD
(xi ) + Ï‰ÌƒD (xi )] + [rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 ) âˆ’ rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (xi )]
âˆ’
â‰¤ 2[rÌƒD
(xi ) + Ï‰ÌƒD (xi )] + Ï‰(D)
âˆ’
+
2d â‰¥ rÌƒD
(xi ) + rÌƒD
(xi )
+
+
âˆ’
= 2[rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (xi )] âˆ’ [rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (xi ) âˆ’ rÌƒD
(xi )] + Ï‰ÌƒD (xi )
+
â‰¥ 2[rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (xi )] âˆ’ Ï‰(D) + 0

â€¢ xâˆ— = xi+1 in the general case
âˆ’
+
2d â‰¥ rÌƒD
(xi ) + Ï‰ÌƒD (xi ) + rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 )
+
= 2[rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 )]
+
âˆ’
âˆ’ [rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 ) âˆ’ rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (xi )]
+
â‰¥ 2[rÌƒD
(xi+1 ) + Ï‰ÌƒD (xi+1 )] âˆ’ Ï‰(D)
âˆ’
+
2d â‰¤ rÌƒD
(xi+1 ) + rÌƒD
(xi+1 )
âˆ’
= 2[rÌƒD
(xi+1 ) + Ï‰ÌƒD (xi+1 )]
+
âˆ’
+ [rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (xi+1 ) âˆ’ rÌƒD
(xi+1 )] âˆ’ Ï‰ÌƒD (xi+1 )
âˆ’
â‰¤ 2[rÌƒD
(xi+1 ) + Ï‰ÌƒD (xi+1 )] + Ï‰(D) âˆ’ 0

Now we are ready to introduce the prune operation. Given a
+ âˆ’
quantile summary Q(D) = (S, rÌƒD
, rÌƒD , Ï‰ÌƒD ) with S = {x1 , x2 , Â· Â· Â· , xk }
elements, and a memory budget b. The prune operation creates
+ âˆ’
another summary Q0 (D) = (S 0 , rÌƒD
, rÌƒD , Ï‰ÌƒD ) with S 0 = {x01 , x02 , Â· Â· Â· , x0b+1 },
where x0i are selected by query the original summary such that


iâˆ’1
Ï‰(D) .
x0i = g Q,
b
+ âˆ’
The definition of rÌƒD
, rÌƒD , Ï‰ÌƒD in Q0 is copied from original summary Q, by restricting input domain from S to S 0 . There could
be duplicated entries in the S 0 . These duplicated entries can be
safely removed to further reduce the memory cost. Since all the
elements in Q0 comes from Q, we can verify that Q0 satisfies all
the constraints in Definition A.1 and is a valid quantile summary.

Theorem A.2. Let Q0 (D) be the summary pruned from an
-approximate quantile summary Q(D) with b memory budget.
Then Q0 (D) is a ( + 1b )-approximate summary.
Proof. We only need to prove the property in Eq. (23) for Q0 .
Using Lemma A.4, we have
iâˆ’1

+ 0
Ï‰(D) + Ï‰(D) â‰¥ rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (x0i )
b
2

iâˆ’1
âˆ’ 0
Ï‰(D) âˆ’ Ï‰(D) â‰¤ rÌƒD
(xi ) + Ï‰ÌƒD (x0i )
b
2
Combining these inequalities gives
+ 0
âˆ’ 0
rÌƒD
(xi+1 ) âˆ’ Ï‰ÌƒD (x0i+1 ) âˆ’ rÌƒD
(xi ) âˆ’ Ï‰ÌƒD (x0i )

i

iâˆ’1

1
â‰¤[ Ï‰(D) + Ï‰(D)] âˆ’ [
Ï‰(D) âˆ’ Ï‰(D)] = ( + )Ï‰(D)
b
2
b
2
b
